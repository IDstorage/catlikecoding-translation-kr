> 번역본에 사용된 이미지, 코드와 같은 모든 리소스와 내용 그 자체의 출처를 아래 명시합니다.<br>
> https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/  

> original author: Jasper Flick (Catlike Coding)<br>
> translator: Minjong Kim (IDstorage)<br>
> lastest update: 2022.09.21

<br>

# 게임 오브젝트와 스크립트
#### 시계 만들기

> 간단한 오브젝트로 시계 만들어보기<br>
> C# 코드 작성해보기<br>
> 시계바늘을 돌려 시간 표시해보기<br>
> 시계바늘 애니메이션 제작해보기<br>

<br>

Unity의 기초를 배우는 시리즈의 첫 강의에 오신 것을 환영합니다. 이번 강의에서는 현재 시간을 표시할 수 있는 기능을 구현하고 간단한 시계를 만들겁니다. Unity 에디터에 대한 경험이 없더라도 좋습니다. 하지만 최소한 (포토샵처럼 분할 창이 즐비한) 멀티윈도우 프로그램/에디터에 대한 경험이 있다는 전제 하에 강의를 풀어나갑니다.

저자의 모든 강의 하단에 링크를 타고 가시면 완성된 강의 프로젝트, 강의 PDF, 라이선스를 볼 수 있습니다.

> 이 강의는 Unity 2020.3.6f1 버전에서 작성되었습니다.

<br>

<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/190963209-c3cd5d9b-b11c-491f-8270-45c0d9deaa39.jpg' width='60%'/>
  <br>
  <i>시계 하나 만들어봅시다.</i>
</p>

<br>

## 1 프로젝트 생성

Unity 에디터로 뭔가 엄청난 것을 하기 전에 먼저 프로젝트를 생성해야 합니다.

<br>

### 1.1 새 프로젝트

Unity를 실행하시면 Unity Hub가 보일 겁니다. Unity Hub는 새 Unity 버전을 설치하거나 프로젝트를 생성/열람할 수 있는 설치 어플리케이션 겸 런쳐입니다. 혹시 Unity 2020.3 이상 버전이 아직 없다면 지금 추가하세요.

><details>
> <summary>어느 버전이 적당한가요? 버전이 너무 많네요.</summary>
> 	<br>유니티는 매년 수많은 버전을 출시합니다. 크게 두 가지 출시 스케쥴이 있는데요. 가장 안정적인건 LTS 릴리즈입니다. LTS는 ```Long Term Support```의 약자로 지원 기간은 2년입니다. (강의 내에선 LTS를 지향합니다.)  버전 구분의 세 번째 숫자는 패치 버전입니다. 버그 수정이나 정말 가끔 새 기능이 추가될 때 이 숫자가 올라가죠. 마지막에 붙는 f1 접미사는 공식적인 최종 버전을 나타냅니다. 2020.3 버전대는 이 강의에 사용 가능합니다.<br><br>가장 최신 버전은 개발 브랜치로, 새로운 기능을 소개하거나 예전 기능을 제거할 가능성이 있습니다. LTS 만큼 신뢰있는 버전은 아닙니다.
> </details>
<br>

가끔 저자의 강의에는 간단한 QnA가 포함되어 있습니다. (항상 저렇게 접혀있습니다.) 

다시 본론으로 돌아와서, 새 프로젝트 생성을 누르면 (설치된) Unity 버전과 템플릿을 선택할 수 있습니다. 우리는 기본 3D 템플릿을 사용할 겁니다. 이렇게 생성한 프로젝트는 Unity Hub에 있는 실행 가능한 프로젝트 목록에 등록되며 클릭 시 설치된 버전 중 맞는 Unity 버전으로 자동 실행해줍니다.

><details>
> <summary>혹시 다른 렌더링 파이프라인을 사용하는 프로젝트로 생성해도 되나요?</summary>
> 	<br>네. 큰 차이는 없습니다. 다만 기본 3D 프로젝트보다 뭔가 많이 추가되어 있을겁니다. 기본 제공 씬과 머터리얼들도 다르게 보일거구요. 아, 몇몇 패키지도 추가되어 있겠군요.
> </details>
<br>

<br>

### 1.2 에디터 레이아웃

만약 따로 에디터를 수정하지 않았다면 아래와 같은 화면이 보입니다.

<br>

<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/190963474-98e8e336-8b7c-4331-a5c2-159556faf88b.png' width='70%'/>
  <br>
  <i>기본 에디터 레이아웃(화면 구성)</i>
</p>

<br>
  
기본 화면 구성은 우리가 사용할 모든 창(이하 뷰)들이 나와있고 원하는대로 뷰를 재배치할 수 있습니다. 당연히 뷰를 닫거나 새 뷰를 열 수도 있죠. 각각의 뷰들은 우측 상단에 ... (점 세 개 아이콘) 을 눌러 해당 뷰의 설정에 접근할 수 있습니다. 만약 화면이 보이는 것과 다르다면 (예를 들어 Scene 뷰가 skybox 대신 단색 배경이라면) 옵션 중 하나가 다를겁니다.

Unity 에디터 우측 상단 Layout 드롭다운 박스를 통해 실행 시 보일 화면 구성을 변경할 수 있습니다. 지금 현재 화면 구성을 저장하고 불러올 수도 있습니다.

<br>

### 1.3 패키지

Unity의 기능은 **패키지** 단위로 모듈화되어 있습니다. 주요 기능 뿐만 아니라 다운로드받아 프로젝트에 포함시킬 수 있는 여러 패키지들도 있습니다. 우리가 생성한 3D 프로젝트에는 몇가지 패키지가 이미 추가되어 있습니다. Project뷰 하단 *Packages* 부분을 확인해보세요.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/190968317-532cf68c-2686-49ed-b4c2-c690982b18c5.png' width='35%' />
  <br>
  <i>기본적으로 추가되어 있는 패키지들</i>
</p>
<br>

Project창 우측 상단에 있는 눈 모양 아이콘을 클릭하여 이 패키지들을 표시할지 안 할지 선택할 수 있습니다. 실제로 프로젝트에서 영영 사라지진 않습니다. 표시만 안 하므로 Project뷰가 지저분해지는 것을 막아주며 버튼을 잘 보시면 몇개의 패키지가 숨겨졌는지도 표시해줍니다.

Package Manager(상단 *Window / Package Manager* 메뉴)를 통해 어떤 패키지를 포함/제거할지 고를 수 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/190969946-175e777f-8982-4b65-a1c0-2f526d0f8018.png' width='80%' />
  <br>
  <i>Package Manager, "현재 추가된 패키지만 보기" 옵션</i> 
</p>
<br>

**패키지**는 Unity에 여러 기능을 추가해줍니다. (예를 들어, *Visual Studio Editor 패키지*는 Visual Studio로 프로젝트 내 C# 스크립트를 수정하기 위한 통합 기능을 제공합니다.) 이 강의에서는 방금 말한 Visual Studio Editor 외 패키지들은 필요가 없으니 제거하도록 합니다. 만약 다른 툴을 사용하신다면 해당하는 통합 패키지를 찾아 추가해보세요. 없을 수도 있습니다.

><details>
> <summary>Visual Studio Code Editor 패키지도 필요하지 않나요?</summary>
> 	<br>이름이 비슷하지만 *Visual Studio*와 *Visual Studio Code*는 서로 다른 에디터입니다. 어떤 것을 사용하느냐에 따라 두 패키지 중 하나만 있으면 됩니다.
> </details>
<br>

패키지를 제거하려니 뭔가 너무 많이 보여 어지럽습니다. 좌측 상단 *Package:* 드롭다운을 눌러 *In Project*를 선택하면 현재 프로젝트에 추가된 패키지만 보여 작업하기 수월합니다. 원하는 패키지를 선택하고 우측 하단 Remove 버튼을 누르면 패키지가 제거됩니다. 매번 패키지를 지울 때 마다 Unity는 프로젝트를 다시 컴파일하기에 시간이 조금 걸릴 겁니다.

저자의 경우 Custom NUnit, Test Framework, Visual Studio Editor 패키지만 남기고 다 지웠습니다. 주구장창 얘기하던 Visual Studio Editor 패키지 말고도 두 개를 더 남겼는데 저 두 패키지들은 Visual Studio Editor 패키지에 **종속성(dependency)이 있기 때문**에 지우지 않았습니다. (Visual Studio Editor 패키지를 사용하기 위해서는 저 두 패키지가 필요하다는 의미입니다.)

이러한 종속성과 (이로 인해)암묵적으로 추가된 패키지를 보려면 Project Settings창(상단 *Edit / Project Settings* 메뉴)의 Package Manager 탭에서 *Advanced Settings* 하위 **Show Dependencies**를 체크해야 합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/190985600-2560db7c-c998-4e66-bdd2-729b1832a263.png' width='80%' />
  <br>
  <i>Show Dependencies가 체크된 Project Settings/Package Manager탭</i> 
</p>
<br>

<br>

### 1.4 색 공간(Color Space)

요즘 렌더링은 대부분 선형 색 공간(Linear color space)을 사용하지만 Unity는 여전히 감마 색 공간(Gamma color psace)을 기본 설정으로 사용합니다. 최상의 때깔을 뽑아내기 위해서는 이를 변경할 필요가 있습니다. Project Settings창에서 Player탭을 들어간 후 *Other Settings* 패널을 열어줍니다. 이어서 *Rendering* 항목을 찾은 다음 첫 번째 설정인 Color Space(색 공간) 값을 **Linear**로 변경하면 됩니다. Unity가 시간이 걸릴 수 있다고 경고하지만 현재의 빈 프로젝트를 상대로는 의미없습니다. 확인을 눌러주시면 됩니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/190987608-b588b6c8-6c0b-4741-bbfc-8b178c61bc01.png' width='80%' />
  <br>
  <i>선형(Linear)으로 설정된 색 공간(Color space)</i> 
</p>
<br>

><details>
> <summary>감마 색 공간(Gamma color space)을 사용할 이유가 있나요?</summary>
> 	<br>구형 기기를 대상으로 게임을 제작한다면 필요합니다. OpenGL ES 2.0과 WebGL 1.0은 선형 색 공간(Linear color space)을 지원하지 않기 때문입니다. 또한, 구형 기기를 대상으로는 감마 색 공간이 훨씬 빠릅니다.
> </details>
<br>

<br>

### 1.5 예제 씬(Scene)

새 프로젝트에는 *SampleScene*이라고 하는 씬(Scene)이 탑재되어 있습니다. 맞습니다. 지금 열려있는 Scene뷰에서 보이는 풍경이 SampleScene입니다. 해당 Scene은 Project뷰 *Assets/Scenes* 에 있습니다. 이 역시 프로젝트를 생성할 때 만들어진 폴더입니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191045460-9eebf18e-4cee-4191-96c6-5aab9264fc0e.png' width='50%' />
  <br>
  <i>Project뷰에서 본 SampleScene 에셋</i> 
</p>
<br>

Project뷰는 2열 구성(two-column layout)이 기본 설정입니다. ...을 눌러 1열 구성(one-column layout)으로 변경할 수 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191048198-6b6d29c3-3ba3-46ca-8efd-e0c62237e0b2.png' width='25%' />
  <br>
  <i>1열 구성(one-column layout)</i>
</p>
<br>

SampleScene에는 메인 카메라와 Directional Light이 있습니다. 이걸 게임 오브젝트(Game Object)라고 합니다. 게임 오브젝트들은 Hierarchy뷰의 Scene 아래에 정렬되어 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191048935-fa077296-4e66-4019-9196-38b5be86818a.png' width='40%' />
  <br>
  <i>Scene 내에 있는 오브젝트 계층(hierarchy)</i>
</p>
<br>

Hierarchy뷰나 Scene뷰를 눌러 각 게임 오브젝트들을 선택할 수 있습니다. 카메라(Main Camera 게임 오브젝트)는 구식 필름 카메라 아이콘으로 Scene뷰에 표시되고 Directional Light는 태양 아이콘으로 표시됩니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191049576-1c5fa8d9-9186-4f65-960a-a28d850fa35a.png' width='40%' />
  <br>
  <i>Scene뷰 속 아이콘</i>
</p>
<br>

><details>
> <summary>Scene뷰는 어떻게 돌아다니나요?</summary>
> 	<br>Alt나 Option키와 마우스를 사용해 (혹은 그냥 마우스 우클릭) 화면을 회전시킬 수 있습니다. 이 상태에서 방향키로 시점을 이동시킬 수 있고 마우스 스크롤로 줌인/아웃할 수 있습니다. 그리고 F키를 눌러 선택한 게임 오브젝트로 포커싱할 수 있습니다. 그 외에도 여러 조작 방법과 기능들이 있지만 지금은 이정도로 충분히 돌아다닐 수 있습니다.
> </details>
<br>

게임 오브젝트가 선택되면 해당 오브젝트의 자세한 정보가 Inspector뷰에 표시됩니다. 하지만 당장은 카메라나 빛을 수정하지 않기에 잠시 화면에서 거슬리는 아이콘을 지워봅시다. Hierarchy뷰 게임 오브젝트 리스트 왼쪽에 있는 눈 모양 아이콘을 클릭하여 게임 오브젝트를 Scene뷰에 표시할지 선택할 수 있습니다. 이 기능을 잘 활용하면 자칫 난잡해질 수 있는 Scene뷰를 정리할 수 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191052840-45dd0895-bcd1-4ac6-a5aa-bcb8d77d3d03.png' width='30%' />
  <br>
  <i>숨겨진 게임 오브젝트들</i>
</p>
<br>

><details>
> <summary>눈 모양 아이콘 옆에 있는 손 모양 아이콘은 뭔가요?</summary>
> 	<br>눈 모양 아이콘 옆 줄은 손 모양 아이콘 줄입니다. 눈 모양 아이콘처럼 기본은 비활성화이며 활성화 시 Scene뷰에서 해당 게임 오브젝트를 선택할 수 없습니다. Scene에 여러 오브젝트가 겹쳐있거나 선택할 필요가 없는 오브젝트에 활성화시키면 Scene뷰를 조작하기 훨씬 편해집니다.
> </details>
<br>

<br>

## 2 간단한 시계 제작

드디어 시계를 제작할 준비가 되었습니다.

<br>

### 2.1 게임 오브젝트 생성

시계를 표현하기 위해 게임 오브젝트가 하나 필요합니다. 가장 기본적인 빈 게임 오브젝트로 시작해보죠. 상단 *GameObject / Create Empty*를 누르거나 Hierarchy뷰 좌측 상단 + 모양 컨텍스트 메뉴(혹은 Hierarchy뷰에서 우클릭)의 *Create Empty* 옵션을 선택하여 빈 게임 오브젝트를 생성할 수 있습니다. 그럼 바로 SampleScene에 게임 오브젝트가 추가되며 자동으로 Hierarchy뷰에서 선택됩니다. 아래 이미지처럼 SampleScene 이름 옆에 애스터리스크가 붙어 있는 것은 Scene에 변경사항이 있고 아직 저장되지 않은 상태라는 의미입니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159557-ae9c0313-b580-4c52-8992-a65ebd9e4a21.png' width='30%' />
  <br>
  <i>새로 생성한 게임 오브젝트가 선택된 Hierarchy뷰</i>
</p>
<br>

게임 오브젝트가 선택된 동안 Inspector뷰에서 해당 오브젝트의 정보를 볼 수 있습니다. 상단 헤더엔 게임 오브젝트의 이름과 여러 설정들이 있습니다. 기본적으로 오브젝트는 켜져있고(enabled) 정적 오브젝트(static)가 아니며 태그가 없고(Untagged) default 레이어로 설정되어 있습니다. 이름 빼고는 참 완벽하죠? 이름을 *Clock*으로 바꿔봅시다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159612-76a58beb-e41b-4dab-ab2c-da8412ad7ab6.png' width='45%' />
  <br>
  <i>Clock 게임 오브젝트가 선택된 Inspector뷰</i>
</p>
<br>

헤더 밑은 게임 오브젝트에 포함된 **컴포넌트(Component)** 리스트 입니다. 항상 게임 오브젝트에는 상단에 [Transform](https://docs.unity3d.com/ScriptReference/Transform.html) 컴포넌트가 있으며 이 컴포넌트는 위치(position), 회전(rotation), 크기(scale)를 조절하는 역할을 합니다. Clock 오브젝트의 위치와 회전값이 전부 0으로 되어 있는지, 크기는 전부 1로 되어 있어야 합니다.

><details>
> <summary>x, y, z면 3D인데.. 2D 오브젝트는요?</summary>
> 	<br>2D에서 작업하신다면 x, y, z중 한 차원을 무시해도 됩니다. UI요소 같은 2D 게임 오브젝트는 일반적으로 <a href="https://docs.unity3d.com/ScriptReference/Transform.html">Transform</a> 컴포넌트를 상속받은 <b><a href="https://docs.unity3d.com/ScriptReference/RectTransform.html">RectTransform</a></b> 컴포넌트가 대신 추가되어 있습니다.
> </details>
<br>

지금은 게임 오브젝트 내에 아무것도 없기에 Scene뷰에서도 제대로 보이지 않습니다. 대신 Transform 조작 툴은 오브젝트의 위치인 월드 중앙에 보일 겁니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159654-b566fc3d-a5ec-4da7-b9b8-7c2209c27a18.png' width='30%' />
  <br>
  <i>이동 툴이 선택된 모습</i>
</p>
<br>

><details>
> <summary>Clock 오브젝트를 눌렀는데도 조작툴이 안 보여요.</summary>
> 	<br>조작 툴은 <b>Scene뷰</b>에서만 보입니다. Game뷰에서는 보이지 않습니다.
> </details>
<br>

어떤 조작 툴을 활성화할지는 에디터 좌측 상단 버튼들로 선택할 수 있습니다. 클릭 뿐만 아니라 각각 Q, W, E, R, T, Y키에 단축키로서 대응됩니다. 맨 오른쪽 버튼(Y에 대응)은 커스텀 에디터 툴입니다. (지금은 없습니다.) 기본으로는 이동 툴(W에 대응)이 선택되어 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159678-f10274dc-3500-4af3-8626-af54d3c009d4.png' width='60%' />
  <br>
  <i>조작 툴이 있는 에디터 툴바</i>
</p>
<br>

조작 툴 옆에는 툴 핸들 위치 기준(Tool Handle Position), 툴 핸들 회전 기준(Tool Handle Rotation), 그리드 가시성(Grid snapping)을 담당하는 버튼들이 놓여 있습니다.

<br>

### 2.2 시계 앞면 제작

Clock 오브젝트를 만들었지만 아직 아무것도 보이지 않습니다. 뭐라도 보이게 하기 위해 3D 모델들을 추가해볼겁니다. Unity는 기본 3D 모델을 몇가지 제공하는데 그걸 사용해서 시계를 만들어볼 예정입니다. 상단 *GameObject / 3D Object / Cylinder*로 원통 모델을 하나 추가해봅시다. 이때 [Transform](https://docs.unity3d.com/ScriptReference/Transform.html) 컴포넌트의 값들(위치, 회전, 크기)이 Clock 오브젝트의 값과 일치하게 조절합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159703-5f88b5a2-4eaf-400c-9a33-1385cc1f5ccc.png' width='20%' />
  <img src='https://user-images.githubusercontent.com/31071467/191159736-dbfdce1f-aa8d-4b41-b15b-0a7ea47735ca.png' width='40%' />
  <br>
  <i>원통(Cylinder) 게임 오브젝트</i>
</p>
<br>

새로 만든 오브젝트는 Clock 오브젝트에 비해 컴포넌트가 3개 더 있습니다. 우선 Unity 내장 원통 3D 메시(mesh)을 참조(reference)하는 ```MeshFilter```라는 컴포넌트입니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159793-5b0f4862-d8d9-4570-8618-f38c27cdc6d4.png' width='40%' />
  <br>
  <i>원통(Cylinder)로 설정된 MeshFilter 컴포넌트</i>
</p>
<br>

두번째는 ```MeshRenderer```입니다. 이 컴포넌트는 오브젝트의 메시가 렌더링 되도록 하는 역할을 합니다. 또한 렌더링에 어떤 머터리얼(material)을 사용할지 고를 수 있습니다.(현재는 기본 머터리얼이 들어있습니다.) 선택된 머터리얼은 MeshRenderer 컴포넌트의 Materials 항목에 표시됩니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159814-572f5a0b-aeb3-49a3-904a-4fa849e7b7ed.png' width='40%' />
  <br>
  <i>기본 머터리얼로 설정된 MeshRenderer 컴포넌트</i>
</p>
<br>

마지막은 3D 물리 연산에 사용될 ```CapsuleCollider```입니다. 그런데 우리가 생성한건 원통인데 왜 캡슐 모양 콜라이더(collider/충돌체)가 추가된 걸까요? Unity는 기본 제공 원통 충돌체가 없기 때문입니다. 사실 이 컴포넌트는 지금 당장 시계를 던질 것도 아니니 필요는 없습니다.  우측 상단 ... 드롭다운 메뉴 *Remove Component* 옵션으로 컴포넌트를 제거해봅시다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159841-e18b1ba9-7d5f-42cb-baa5-2f52de537918.png' width='40%' />
  <br>
  <i>콜라이더 없는 원통</i>
</p>
<br>

원통을 납작하게 만들어 시계의 앞면으로 사용할겁니다. 간단합니다. 크기(scale)의 y 요소를 0.2로 줄여 납작하게 만들 수 있습니다. 기본 원통의 높이가 2이므로 지금 높이는 0.4가 되었네요. 이제 납작하긴 한데 크기가 너무 작습니다. x와 z요소를 모두 10으로 맞춰주세요.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159878-74184d71-89a0-496a-9bc8-577621777bed.png' width='40%' />
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191159895-924df7c9-8368-42d3-a796-d312a37f1253.png' width='40%' />
  <br>
  <i>크기 조절한 원통</i>
</p>
<br>

우리가 만들 시계는 벽걸이지 바닥에 놓고 보는 시계가 아닙니다. 그런데 지금 시계는 바닥에 누워있군요. 90도 정도 돌려서 문제를 해결해봅시다. Unity에서는 X축은 오른쪽, Y축은 위쪽, Z축은 앞쪽을 가리킵니다. 자, 우리가 시계를 보는 상황을 감안하여 설계해봅시다. 시계의 앞면을 보기 위해 Z축에 서서 보게 됩니다. 이젠 시계가 된 원통의 X축을 90도 회전하여 시계의 앞면이 Z축에 서 있는 우리들의 시야에 보이도록 맞춥니다. 이동 툴의 파란 Z축 화살표가 화면을 향해, 우리 시야와 동일한 방향이 될겁니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159921-f331d982-0265-4a8b-810a-11e075756077.png' width='40%' />
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191159944-8786dc38-63c6-47d1-9b00-b5a1e236c30a.png' width='40%' />
  <br>
  <i>회전한 원통</i>
</p>
<br>

"원통(Cylinder)"이라는 이름만으로는 시계의 어떤 부분인지 알 수 없습니다. 구분하기 쉽게 Face로 이름을 변경합시다. Face 게임 오브젝트는 *시계의 한 파트*기 때문에 Clock 오브젝트의 자식(child)로 만들겁니다. Hierarchy뷰에서 Face 오브젝트를 Clock 오브젝트 위로 드래그하여 부모-자식 계층 구조를 만들 수 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191159971-fcbab914-ba8c-400b-862f-4856cf129a13.png' width='30%' />
  <br>
  <i>자식 오브젝트가 된 Face</i>
</p>
<br>

자식 오브젝트는 부모 오브젝트의 Transform 변경 정보에 영향을 받습니다. Clock 오브젝트를 움직이면 Face 오브젝트도 동일하게 움직입니다. 이는 마치 둘이 하나의 오브젝트인 마냥 위치, 회전, 크기 변경에 동일하게 반응합니다. 잘 활용하면 복잡한 오브젝트를 계층 구조로 표현할 수 있습니다.

<br>

### 2.3 시계 인덱스 제작

시계의 가장자리에는 현재의 시, 분, 초를 나타내는 "인덱스" 파츠가 존재합니다. 블록을 사용해 시(hour)를 표현하는 인덱스를 만들어봅시다.

상단 *GameObject / 3D Object / Cube*를 눌러 큐브 오브젝트를 하나 생성합니다. 이름은 *Hour Indicator 12*로 변경하고 Face 오브젝트처럼 Clock 오브젝트의 자식으로 등록합니다. 자식 계층간의 순서는 중요하지 않습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196099-81cbff7d-ff37-471f-a05e-71cc88698556.png' width='30%' />
  <br>
  <i>자식 오브젝트가 된 Hour Indicator 12</i>
</p>
<br>

> 번역 주석<br>
> 위치, 회전(오일러), 크기를 변경할 때 *x는 몇, y는 몇, z는 몇* 대신 **(x, y, z)** 식으로 표현합니다.

<br>

Hour Indicator 12 오브젝트의 크기를 *(0.5, 1, 0.1)* 로 변경하여 평평하고 얇고 긴 블록이 되도록 합니다. 위치는 *(0, 4, -0.25)* 로 변경하여 12시 위치에 가도록 합니다. Face 오브젝트와 마찬가지로 필요없는 ```BoxCollider``` 컴포넌트는 제거합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196156-d1cb11ed-5bde-4fd2-bf3f-9a0bdebd83b6.png' width='25%' />
  <img src='https://user-images.githubusercontent.com/31071467/191196204-b2451b8f-cc55-45f0-a1b5-9d9dfe4c9690.png' width='40%' />
  <br>
  <i>Hour Indicator 12의 <a href="https://docs.unity3d.com/ScriptReference/Transform.html">Transform</a> 컴포넌트</i>
</p>
<br>

다 같은 흰색이라 인덱스가 제역할을 못하고 있습니다. 다른 머터리얼을 만들어 식별하기 편하게 바꿔봅시다. **Project뷰** 좌측 상단 + 버튼이나 우클릭 메뉴의 *Assets / Create / Material* 을 눌러 새로운 머터리얼을 생성합니다. Project뷰를 보면 기본 제공 머터리얼의 복사본이 생성된 것을 확인할 수 있는데 *Hour Indicator*로 이름을 변경합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196254-cd39979d-fce8-4215-80b9-d991e2a3b222.png' width='25%' />
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191196275-683b36aa-7f9f-4e8a-9b58-de6c6782c2ab.png' width='40%' />
  <br>
  <i>1열과 2열 구성으로 본 Project뷰에서의 Hour Indicator 머터리얼</i>
</p>
<br>

머터리얼을 클릭해 Inspector뷰에서 세부 정보를 볼 수 있습니다. 속성 중 **Albedo** 값을 다른 아무 값으로 변경합니다. 이는 색상값으로 우리는 진한 회색(HEX494949, RGB(73, 73, 73))으로 바꿔봅시다. 색상값의 알파(A)를 비롯한 나머지 속성들은 건드리지 않습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196332-ded6850a-7d90-4497-997e-626a2005188e.png' width='25%' />
  <br>
  <i>Albedo: 진한 회색</i>
</p>
<br>

> <details>
> <summary>알베도(Albedo)가 뭔가요?</summary>
> 	<br>알베도는 라틴어로 "흰 정도"를 의미하며 흰색 빛으로 비췄을 때 보이는 색상입니다.
> </details>
<br>

이제 만든 머터리얼을 적용해봅시다. Project뷰에 있는 Hour Indicator 머터리얼을 Scene뷰나 Hierarchy뷰에 있는 인덱스 오브젝트로 끌어다 놓습니다. 인덱스가 선택된 상태에서 Inspector뷰 하단으로 끌어도 되며 ```MeshRenderer``` 컴포넌트의 속성 중 *Materials 배열의 Element 0* 으로 끌어도 됩니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196380-bb2e28dd-27ca-402a-b26c-2193323e064e.png' width='25%' />
  <img src='https://user-images.githubusercontent.com/31071467/191196386-238255de-6c1d-4b67-b91e-c4c6f7189bad.png' width='40%' />
  <br>
  <i>진한 회색으로 변한 12시 인덱스</i>
</p>
<br>

<br>

### 2.4 12개의 인덱스

12시 인덱스 하나로 진행할 수 있지만 시계답게 1시부터 11시까지의 인덱스도 추가해봅시다. 작업하기 편하게 Scene뷰를 마치 직접 시계를 보듯 Z축을 따라 정렬합니다. Scene뷰 우측 상단 축 아이콘을 클릭하여 시점을 변경할 수 있습니다. 그리드 툴바 버튼으로 Z축 격자를 표시할 수도 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196443-294d32aa-ca61-4361-a33f-9a4e94a29f61.png' width='50%' />
  <br>
  <i>Z축을 따라 시계를 정면에서 바라본 모습</i>
</p>
<br>

키보드 단축키(Ctrl+D)나 마우스 우클릭, 상단 *Edit / Duplicate* 메뉴로 Hour Indicator 12 오브젝트를 복사합니다. Hierarchy뷰를 보면 바로 밑에 복사된 오브젝트 *Hour Indicator 12 (1)* 이 있을겁니다. 이름은 Hour Indicator 6로 변경하고 Y 위치값을 음수로 변경합니다. 시계의 6시 위치에 인덱스가 위치한 것을 볼 수 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196486-43d2f977-3fd8-475e-a8f5-e892d6af8c35.png' width='27%' />
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191196494-e11f73cd-f6fb-4bf3-8fb5-bc76d9921b8b.png' width='30%' />
  <br>
  <i>12시와 6시에 배치된 인덱스</i>
</p>
<br>

3시와 9시 인덱스도 같은 방식으로 생성해줍니다. 이번엔 Y 위치값을 0으로 고정하고 X 위치값을 4와 -4로 설정해야 합니다. 인덱스의 방향도 중요하니 Z축으로 90도 회전해야 옆으로 누운 인덱스를 만들 수 있습니다. (물론 복사된 인덱스 오브젝트의 이름을 바꾸는 작업도 잊지 마세요.)

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196551-afd40b2d-3566-4115-a8c9-c66e67e0c1dd.png' width='30%' />
  <br>
  <i>네 방향에 배치된 인덱스들</i>
</p>
<br>

이번엔 다시 Hour Indicator 12를 복사하고 *Hour Indicator 1*로 이름을 변경합니다. X와 Y 위치값을 각각 2, 3.464로 변경하고 Z축으로 -30 회전합니다. 이렇게 만든 1시 방향 인덱스를 다시 복사하여 *Hour Indicator 2*로 이름을 변경한 후 X와 Y 위치값을 서로 바꿉니다. Z축 회전도 -60 으로 변경합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196592-40e9ec2e-ca6e-4d6c-b3ae-5cf3598498a9.png' width='30%' />
  <br>
  <i>1시와 2시에 배치된 인덱스들</i>
</p>
<br>

> <details>
> <summary>3.464같은 수는 어디서 나온건가요?</summary>
> 	<br>매 시는 Z축 기준 시계방향으로 30°씩 증가합니다. Unity의 회전 체계가 반시계방향이기 때문에 음수를 취했습니다. 1시 인덱스의 위치는 삼각법(trigonometry)으로 구할 수 있습니다. 삼각법에 의해 sin30° 는 $1\over 2$이고 cos30°은 $\sqrt 3\over 2$ 입니다. 이 값은 X와 Y 위치값으로 대응되며 이를 중심에서 인덱스까지의 거리인 4만큼 늘렸습니다. 그리하여 X는 2, Y는 $2\sqrt 3 \approx 3.464$가 됩니다. 2시 인덱스인 60°는 sin60°=cos30°, cos60°=sin30°기 때문에 단순히 X와 Y 위치값을 바꿔줬습니다.
> </details>
<br>

이 두 인덱스들을 복사한 후 Y 위치값을 반전시켜 4시, 5시 인덱스를 만들고 Z 회전값을 조절합니다. 1시, 2시, 4시, 5시 인덱스를 복사하여 같은 원리로 나머지 인덱스도 배치해줍시다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196647-4b694963-20f5-41f1-8ad7-1510569766ea.png' width='30%' />
  <br>
  <i>드디어 인덱스가 모두 배치되었습니다.</i>
</p>
<br>

<br>

### 2.5 시계바늘 추가

이제 시계바늘을 추가해줄 차례입니다. *Hour Indicator 12* 오브젝트를 복사하고 *Hours Arm*으로 이름을 바꿔 시침을 만들어줍니다. 아까처럼 새 머터리얼을 만들고 *Clock Arm*이라고 이름 지은 후 알베도 값을 검은색(HEX000000, RGB(0, 0, 0))으로 설정합니다. Hours Arm 오브젝트의 크기를 (0.3, 2.5, 0.1)로 변경하고 Y 위치값을 0.75로 설정하여 12시를 가리키도록 합니다. (실제 시계처럼 시침이 중심에서 살짝 밑으로 내려와있습니다.)

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191196697-189724df-3937-4485-9dcd-84b824a1c929.png' width='30%' />
  <img src='https://user-images.githubusercontent.com/31071467/191196780-8af3251c-bff6-4e31-bf71-3dda6f45a671.png' width='40%' />
  <br>
  <i>시침 역할의 Hours Arm 오브젝트</i>
</p>
<br>

시계바늘은 시계 중심에서 회전해야 합니다. 하지만 실제로 시침을 회전시켜보면 **시침의 중심**을 기준으로 회전하는 모습을 볼 수 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191197502-bb71cbbe-5931-497d-8ab8-a011f5ae8ff9.gif' width='30%' />
  <br>
  <i>자신의 중심을 기준으로 돌아가는 시침</i>
</p>
<br>

게임 오브젝트의 회전은 자신의 로컬 위치를 기준으로 이루어지기 때문에 이런 현상이 발생합니다. 적절한 회전을 구현하기 위해서는 피벗(pivot) 오브젝트를 추가하여 시침대신 그 오브젝트를 돌리는 방법을 택해야 합니다. 빈 게임 오브젝트를 하나 생성하고 Clock 오브젝트의 자식으로 등록합니다. 이는 Hierarchy뷰에서 Clock 오브젝트를 우클릭하여 생성할 수도 있습니다. 이름을 Hours Arm Pivot으로 변경하고 위치와 회전값이 (0, 0, 0)으로, 크기가 (1, 1, 1)로 되어 있는지 확인하세요. **그런 후** Hours Arm 오브젝트를 Hours Arm Pivot 오브젝트의 자식으로 등록합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191197709-345ee966-18e1-4891-be9e-806b0dcc9785.png' width='25%' />
  <br>
  <i>피벗이 추가된 시침</i>
</p>
<br>

이제 Hours Arm Pivot을 돌려보세요. Scene뷰에서 직접 돌리려면 Tool Handle Position이 Pivot으로 되어 있는지 확인하세요. (Center가 아닙니다!)

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198009-e01ec934-40be-441a-86c6-e7fcc1676dac.gif' width='30%' />
  <br>
  <i>이제 시침이 피벗을 기준으로 회전합니다.</i>
</p>
<br>

*Hours Arm Pivot* 오브젝트를 두번 복사하여 *Minutes Arm Pivot*과 *Seconds Arm Pivot*을 만듭니다. 아래 이미지처럼 이름을 변경합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198084-f9c4ef4f-207f-4101-8197-b7461a2856ca.png' width='30%' />
  <br>
  <i>Hierarchy뷰에서 본 시계바늘들</i>
</p>
<br>

분침은 시침보다 더 좁고 길어야 합니다. **Minutes Arm** 오브젝트의 크기를 (0.2, 4, 0.1)로 변경하고 Y 위치값은 1, Z 위치값은 -0.35로 변경합니다. **주의할 점은 피벗이 아니라 피벗의 자식인 Minutes Arm 오브젝트를 변경해야 합니다.**

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198146-43b366fd-8fb5-4b16-9fbd-c06f6246c06a.png' width='45%' />
  <br>
  <i>Minutes Arm 오브젝트의 <a href="https://docs.unity3d.com/ScriptReference/Transform.html">Transform</a> 컴포넌트</i>
</p>
<br>

**Seconds Arm** 오브젝트도 수정합니다. 이번엔 크기를 (0.1, 5, 0.1), 위치를 (0, 1.25, -0.45)로 수정하여 더 얇고 길게 만들어줍니다. 다시 한번 말하지만 **피벗이 아니라 Seconds Arm** 오브젝트를 수정하고 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198199-bc75f35b-1272-4a14-a2e0-5ef85834099d.png' width='45%' />
  <br>
  <i>Seconds Arm 오브젝트의 <a href="https://docs.unity3d.com/ScriptReference/Transform.html">Transform</a> 컴포넌트</i>
</p>
<br>

시침이 눈에 띄도록 머터리얼을 따로 만들어 줍시다. 저자는 진한 빨강(HEX B30000)을 선택했습니다. 이제 시계를 완성했으니 그리드를 꺼줍니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198244-9c483143-f575-45bb-8f9c-4d7e7a229067.png' width='30%' />
  <br>
  <i>시계바늘을 추가한 시계</i>
</p>
<br>

혹시 아직까지 Scene을 저장하지 않았다면 지금이 저장할 타이밍입니다. 상단 *File / Save* 또는 키보드 단축키(Ctrl+S)로 저장할 수 있습니다.

주기적으로 에셋을 정리하는 것도 좋은 습관입니다. Project뷰 *Assets / Create / Folder*를 눌러 새 폴더를 만들고 지금까지 만든 세 머터리얼을 넣어줍시다. 이름은 Material**s**로 변경합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198292-831570e5-1b6d-4fdc-a4d7-c35d5e523500.png' width='25%' />
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191198296-3bd2fda5-68f3-4f7d-97ba-c693d515faf1.png' width='55%' />
  <br>
  <i>1열/2열 구성으로 본 Project뷰 속 Materials 폴더</i>
</p>
<br>

<br>

## 3 시계에 생명력 불어넣기

방금까지 만든 시계는 겉만 시계지 시간을 제대로 알려주진 않습니다. 계속 정오를 가리키고 있죠. 시간을 보기 위해 우린 새로운 컴포넌트를 스크립트로 제작하고 이를 추가하여 시계로 하여금 각 시계바늘에 맞는 동작을 알려줄 필요가 있습니다. 

<br>

### 3.1 C# 스크립트 에셋

Project뷰에서 *Assets / Create / C# Script* 를 눌러 새로운 C# 스크립트를 생성하고 이름을 Clock으로 변경합니다. C#(*씨-샵*)은 프로그래밍 언어로, Unity 스크립트에 사용됩니다. 물론 Unity에서만 사용하는 언어는 아닙니다. 아, 정리하는 습관 말씀드렸죠? Scripts 폴더를 만들어서 아까 만든 스크립트 파일을 넣어줍시다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198370-5b34add4-f1b4-4c91-ac26-c3376a1eb8ba.png' width='25%' />
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191198383-e0c53d79-f4ff-426e-b0ff-9ae8334a74b9.png' width='40%' />
  <br>
  <i>1열/2열 구성으로 본 Project뷰 속 Clock 스크립트가 들어 있는 Scripts 폴더</i>
</p>
<br>

스크립트가 Project뷰에서 선택되면 Inspector뷰에서 스크립트 내용이 보일겁니다. 볼 수만 있고 수정하기 위해서는 코드 에디터가 필요합니다. 우측 상단 Open 버튼이나 스크립트 에셋을 더블 클릭하여 코드 에디터를 열 수 있습니다. 이때 열리는 에디터는 Unity 설정에 따라 다릅니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191198448-d67b8170-41c7-477b-a3e3-5863a831a829.png' width='40%' />
  <br>
  <i>Inspector뷰에서 본 C# 스크립트 에셋 Clock</i>
</p>
<br>

<br>

### 3.2 컴포넌트 타입 정의

우리는 배우는 입장이라 처음부터 스크립트를 작성하기 위해 코드 에디터가 열리면 기본 템플릿 코드를 전부 지웁니다.

빈 파일은 그저 아무것도 정의되지 않습니다. 우린 이 척박한 땅에 Clock 컴포넌트를 정의해야 합니다. 단순히 컴포넌트의 한 인스턴스를 만드는게 아니라 Clock이라는 일반화된 타입 혹은 클래스를 정의하는 것입니다. 이렇게 클래스를 정의하면 Unity에서 그 이름의 컴포넌트를 계속 생성할 수 있습니다만 여기서는 Clock 컴포넌트 하나만 사용하는 것으로 합니다.

C#에선 (나아가 대부분의 언어에선) 클래스를 정의할 때 클래스를 정의한다고 명시한 후 클래스의 이름이 뒤따릅니다. 아래와 같이 코드를 작성하면 에디터상에서 붉은 밑줄이나 배경이 생기는걸 볼 수 있습니다. 빈 파일에서 시작할 때 그 파일의 내용은 Clock 클래스여야 합니다. 

```c#
class Clock 
```

> <details>
> <summary>클래스(class)가 정확히 뭔가요?</summary>
> 	<br>클래스는 컴퓨터 메모리에 오브젝트를 할당하기 위해 사용되는 일종의 청사진(blueprint)입니다. 이 오브젝트가 어떤 데이터를 포함하는지, 어떤 기능을 가지고 있는지를 나타냅니다.<br><br>또한 오브젝트들이 아닌 클래스 자체에 포함된 데이터나 기능을 정의할 수도 있습니다. 전역에서 접근 가능한 기능을 제공하기 위해 사용되며 곧 우리도 몇가지 써볼겁니다. 하지만 당장 Clock 클래스에는 필요하지 않습니다.
> </details>
<br>

Clock 클래스에 대한 접근을 제한할 필요도 없고 원하지도 않기 때문에 **public 접근 지정자**를 앞에 추가합니다.

```c#
public class Clock
```

> <details>
> <summary>접근 지정자를 명시하지 않은 클래스는 어떻게 되나요?</summary>
> 	<br>접근 지정자 없이는 <b>internal class Clock</b>와 같습니다. 같은 어셈블리(assembly)내에서만 접근 가능하며 다른 어셈블리에 포함된 코드에서 사용할 때 제한이 생깁니다. 항상 접근 가능하도록 하려면, <b>public</b>을 사용하세요.
> </details>
<br>

이 시점에서 코드는 아직 C#문법을 만족하지 않습니다. 지금 파일을 저장하고 Unity로 돌아가보면 *Console뷰*에서 에러 로그를 마주할겁니다.

우린 우리가 어떤 타입을 정의할지 **명시**했으니 이젠 실제로 그 타입을 **정의**해야 합니다. 중괄호로 감싸진 코드 블록이 그 타입을 정의하는 방법입니다. 당장은 코드 블록 내에 아무것도 없어도 됩니다. 그냥 ```{ }```만 작성합니다.

```c#
public class Clock { }
```

이제야 C#문법에 맞는 코드가 되었습니다. 파일을 저장하고 Unity로 돌아가보세요. Unity는 변경된 스크립트 파일을 인식하고 다시 컴파일을 진행합니다. 컴파일이 끝난 후 Project뷰에서 스크립트를 선택해 Inspector뷰를 보면 *[MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) 스크립트가 없거나 클래스의 이름이 파일 이름과 동일하지 않습니다.* 라는 메시지를 띄웁니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191396314-cd55f327-6d9b-46c1-bd2b-33701537f984.png' width='45%' />
  <br>
  <i>컴포넌트가 아닌 스크립트</i>
</p>
<br>

다르게 말해 이 스크립트를 Unity에서 *컴포넌트로* 사용할 수 없다는 뜻입니다. 지금 우리가 정의한 Clock 클래스는 기본 C# 오브젝트 타입으로 정의되어 있습니다. 컴포넌트로 사용하기 위해서는 Unity의 [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) 타입을 상속받아야 합니다.

> <details>
> <summary>mono-behavior가... 뭐죠?</summary>
> 	<br>게임 오브젝트에 우리가 만든 행동이나 기능을 추가하기 위해 컴포넌트를 제작한다는 것을 behavior, 우리가 작성한 코드에 대한 지원이 Unity에 추가된 방식을 mono라 하여 합쳐서 <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html">MonoBehaviour</a>입니다. 정확히는 닷넷(.Net) 프레임워크의 멀티플랫폼을 구축하는 Mono 프로젝트에서 이름을 따왔습니다. 물론 옛날 이름이지만 이전 버전이나 옛날 프로젝트를 위한 하위호환성 때문에 유지하고 있습니다.
> 	<br><br>
> 	참고로 behavior가 아닌 behaviour인 이유는 영국식 영어라 그렇습니다. 
> </details>
<br>

Clock 클래스를 [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)의 하위 유형으로 만들기 위해서는 코드에 작성한 Clock 클래스의 정의를 바꿔야 합니다. 코드 블록을 나타내는 중괄호와 클래스의 이름 사이에 콜론(:)과 함께 받고자 하는 클래스의 이름을 기입합니다. 이렇게 되면 [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) 클래스의 (상속받을 수 있는) 모든것을 물려받습니다.

```c#
public class Clock : MonoBehaviour { }
```

하지만 이렇게 적으면 에러가 발생합니다. 우리의 깐깐하신 컴파일러님은 [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) 뭔지 몰라 못찾겠다고 땡깡을 부리실겁니다. 이는 MonoBehaviour가 UnityEngine이라고 하는 네임스페이스(namespace)에 정의되어 있기 때문입니다. 따라서 [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)를 사용하려면 **어디에 있는 [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)인지** 완전히 명시해줘야 합니다.

```c#
public class Clock : UnityEngine.MonoBehaviour { }
```

> <details>
> <summary>네임스페이스는 뭔가요?</summary>
> 	<br>네임스페이스는 코드에서 웹사이트 도메인 같은 역할을 합니다. 도메인이 하위 도메인을 가질 수 있듯이 네임스페이스도 하위 네임스페이스를 가질 수 있습니다. 가장 큰 차이는 작성 방식이 다르다는 점입니다. forum.unity.com 처럼 쓰는 대신 com.unity.forum 으로 작성합니다. 이런 네임스페이스는 코드를 정리하거나 이름간의 충돌을 방지하기 위해 사용합니다.
> 	<br><br>
> 	어셈블리는 Unity에서 제공한 UnityEngine 코드를 포함하고 있습니다. 따로 온라인에서 설치하거나 업데이트할 필요없습니다. 알맞는 코드 에디터와 그 패키지를 설치했다면 자동으로 인식할겁니다.
> </details>
<br>

매번 UnityEngine 네임스페이스에 포함된 클래스를 사용할 때 ```UnityEngine.```을 붙이면 코드 작성하기 굉장히 불편할겁니다. 다행히 특정 네임스페이스를 계속 명시하지 않아도 해당 파일 내에서 자동으로 인식하게 할 수 있습니다. 파일 첫 줄에 ```using UnityEngine;```를 추가하면 됩니다. 문장 끝에 세미콜론(;)을 빼먹지 마세요.

```c#
using UnityEngine;

public class Clock : MonoBehaviour { }
```

이제 Clock 게임 오브젝트에 우리가 방금까지 심혈을 기울여 만든 컴포넌트를 추가할 수 있게 됩니다. Clock 오브젝트를 선택한 뒤 Project뷰에서 Inspector뷰까지 직접 스크립트 에셋을 드래그하거나 Inspector뷰 하단에 있는 *Add Component* 버튼을 눌러 추가할 수 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191396475-c5fd46ca-4c15-4b7a-970a-0215b3a30435.png' width='45%' />
  <br>
  <i>Clock 컴포넌트를 가진 Clock 게임 </i>
</p>
<br>

참고로 원문과 다른 모든 튜토리얼에 있는 타입들은 모두 Unity 온라인 문서로 연결되는 링크가 달려있습니다. [MonoBehaviour](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html) 이렇게요.

<br>

### 3.3 시계바늘 들고있기

시계바늘을 돌리기 위해서는 ```Clock``` 오브젝트가 시계바늘 오브젝트들을 알고 있어야 합니다. 시침 먼저 해보죠. 모든 게임 오브젝트가 그렇듯 [Transform](https://docs.unity3d.com/ScriptReference/Transform.html) 컴포넌트를 조절하는 것으로 회전시킬 수 있습니다. 그래서 우린 ```Clock```에게 시계바늘의 피벗의 [Transform](https://docs.unity3d.com/ScriptReference/Transform.html) 컴포넌트를 알려줘야 합니다. 코드 블록 내에 데이터 필드를 추가하여 알려줄 수 있습니다. 이때 이름도 정하고 세미콜론도 붙여줘야 합니다.

*hours pivot*이라는 이름이 시침을 나타내기에 적합할 것 같네요. 그러나 띄워쓰기 없는 한 단어로 작성해야 합니다. 보통 사람들은 첫 글자를 소문자로, 이어 나오는 단어들은 첫 글자를 대문자로 하여 붙여씁니다. 우리의 경우 ```hoursPivot```이 되겠네요.

```
public class Clock : MonoBehaviour {
	hoursPivot;
}
```

> <details>
> <summary>using UnityEngine; 는 안 써도 되나요?</summary>
> 	<br>아뇨. 쓰셔야 합니다. 강의를 읽기 편하게 하기 위해 안 적었을 뿐입니다.
> </details>
<br>

이름만 있으면 안 되고 그 데이터가 어떤 타입인지도 명시해야 합니다. [Transform](https://docs.unity3d.com/ScriptReference/Transform.html)(정확히는 UnityEngine.[Transform](https://docs.unity3d.com/ScriptReference/Transform.html))을 이름 앞에 작성해줍니다.

```c#
Transform hoursPivot;
```

드디어 다른 오브젝트의 참조(reference)할 수 있는 [Transform](https://docs.unity3d.com/ScriptReference/Transform.html) 필드가 정의되었습니다. 이제 이 데이터 필드가 시침 오브젝트를 참조하면 됩니다.

기본적으로 필드(field)는 접근 지정자가 private 입니다. 이는 그 필드가 속한 클래스(현재는 Clock)에서**만** 사용할 수 있다는 뜻입니다. 그래서 지금 당장은 Clock 클래스가 우리의 Scene을 알지 못하기 때문에 직접 필드와 게임 오브젝트를 연결할 수는 없습니다. 하지만 필드를 직렬화(serializable)하면 Scene 데이터에 해당 필드가 같이 저장됩니다. Unity는 Scene을 저장할 때 Scene 내에 있는 모든 데이터를 직렬화하여 파일에 저장하는데 이때 포함되는 것입니다.

필드의 직렬화는 ```SerializeField```라는 어트리뷰트(attribute)를 추가하여 구현할 수 있습니다. 필드 앞에 대괄호와 함께 작성하며 보통은 바로 윗줄에 추가하지만 같은 줄에 있어도 상관은 없습니다.

```c#
[SerializeField]
Transform hoursPivot;
```

> <details>
> <summary>음... 그냥 public으로 필드를 만들면 안 되나요?</summary>
> 	<br>됩니다. 하지만 클래스의 필드를 public으로 접근 가능하게 하는건 그리 좋은 습관은 아닙니다. 경험에 의하면 다른 코드에서 필드를 접근해야 할 때 public을 사용하지만 그마저도 필드 자체보다는 그 필드에 접근할 수 있는 public 메서드나 프로퍼티를 선호합니다. 외부에서 접근할 수 있는 방도가 줄어들면 안정성이 늘어 유지보수가 편합니다. 이 강의에서는 C#코드가 Clock밖에 없기에 굳이 public으로 만들 필요는 없습니다.
> </details>
<br>

필드가 직렬화되면 Unity는 이를 감지하고 Inspector뷰 Clock 컴포넌트에 이를 띄워줍니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191396565-0dbdbfc9-0af6-4c68-8a05-4ae58abb4ba9.png' width='40%' />
  <br>
  <i>hoursPivot 필드</i>
</p>
<br>

시침을 제대로 연결하려면 *Hours Arm Pivot* 오브젝트를 Hierarchy뷰에서 드래그하여 Inspector뷰의 *Hours Pivot* 필드로 가져와야 합니다. 아니면 필드 오른쪽에 있는 동그란 버튼을 누르면 뜨는 팝업창에서 오브젝트를 검색하여 추가할 수도 있습니다. 둘다 Unity가 자동으로 [Transform](https://docs.unity3d.com/ScriptReference/Transform.html) 컴포넌트를 *Hours Arm Pivot*에서 가져와 참조시킵니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191396588-56c3cd6a-b211-4297-9c05-4204212d07a2.png' width='40%' />
  <br>
  <i>Hours Arm Pivot 오브젝트가 연결된 hoursPivot 필드</i>
</p>
<br>

<br>

### 3.4 시침, 분침, 초침 참조

같은 방식으로 분침과 초침도 참조해야 합니다. 직렬화된 두 [Transform](https://docs.unity3d.com/ScriptReference/Transform.html) 필드를 추가하고 이름을 변경해주세요.

```c#
[SerializeField]
Transform hoursPivot;

[SerializeField]
Transform minutesPivot;

[SerializeField]
Transform secondsPivot;
```

다 같은 타입과 어트리뷰트를 공유하기 때문에 간단하게 줄일 수 있습니다. 필드 정의 뒤에 콤마(,)로 구분하여 합칠 수 있습니다.

```c#
[SerializeField]
Transform hoursPivot, minutesPivot, secondsPivot;

// [SerializeField]
// Transform minutesPivot;

// [SerializeField]
// Transform secondsPivot;
```

> <details>
> <summary>'//' 이건 뭐하는 건가요?</summary>
> 	<br>'//'는 주석을 의미합니다. 해당 표기 이후 글자는 (해당 줄 한정) 모두 컴파일러가 무시합니다. 코드의 추가적인 설명이 필요하다면 주석을 주로 사용합니다. 위 코드처럼 지울 코드에 대해 주석으로 처리해도 됩니다.
> </details>
<br>

다른 두 시계바늘도 마찬가지로 에디터에서 참조시킵니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191396623-fe196d00-26bd-4c08-8993-49a145cb3cfa.png' width='40%' />
  <br>
  <i>모든 시계바늘이 참조된 모습</i>
</p>
<br>

<br>
