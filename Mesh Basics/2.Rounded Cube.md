> 번역본에 사용된 이미지, 코드와 같은 모든 리소스와 내용 그 자체의 출처를 아래 명시합니다.<br>
> https://catlikecoding.com/unity/tutorials/rounded-cube/

> original author: Jasper Flick (Catlike Coding)<br>
> translator: Minjong Kim (IDstorage)<br>
> lastest update: 2022.09.29

<br>

# 둥근 정육면체
#### 3D로 깨작깨작

> 이격 없는 메시로 정육면체 만들기<br>
> 정육면체에 둥근 모서리 넣기<br>
> 법선 정의하기<br>
> 서브메시(sub-mesh) 사용해보기<br>
> 커스텀 셰이더 작성해보기<br>
> 기본 콜라이더(collider) 결합해보기

<br>

이번 강의에서는 메시 하나로 둥근 정육면체를 만들어 볼겁니다. [절차적 격자](https://github.com/IDstorage/catlikecoding-translation-kr/blob/master/Mesh%20Basics/1.Procedural%20Grid.md) 강의에서 이어집니다.

> 이 강의는 Unity 5.0.1 버전이나 그 이상을 다루고 있습니다.

> 번역 주석<br>
> 편의를 위해 강의 중 나오는 정/직육면체를 이하 모두 '큐브'라고 번역합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/192915067-884841d8-81c1-42d5-9ad8-f5c3869e59fb.jpg' width='60%'/>
  <br>
  <i>다양한 형태의 둥근 큐브</i>
</p>
<br>

## 1 큐브 합치기

2D 격자를 다뤄봤으니 이젠 3D 구조를 절차적으로 생성해볼 차례입니다. 큐브를 한번 봅시다. 정의상 큐브는 3D 볼륨(volume)을 감싸도록 배치/회전된 6개의 2D 면을 가지고 있습니다. 그래서 이전 강의에서 만든 격자 6개로 똑같이 흉내낼 수도 있습니다.

우린 XY 평면에 -Z축을 바라본 형태로 격자를 만들어 봤었습니다. 큐브로 치면 큐브의 -Z면입니다. 이걸 복사하고 Y축으로 180°회전해서 +Z면도 만들 수 있죠. 물론 두 면이 일직선상에 놓이도록 재배치해야겠지만요.

-X와 +X면은 -Z와 +Z면을 복사해 각각 Y축으로 90°, 270°회전하여 만들 수 있습니다. 원한다면 *xSize*를 Z면과는 다르게 줄 수도 있습니다만 X면과 Z면은 세로가 서로 붙어있기에 *ySize*는 같아야 합니다. 회전만 해서는 안 되겠죠. -, +X면도 똑같이 재배치하여 마치 반지처럼 닫힌 링 구조를 만들어야 합니다.

-Y와 +Y면은 X축으로 270°, 90°회전하여 만들 수 있습니다. 주의할 점은 *xSize*는 Z면과, *ySize*는 X면의 *xSize*와 같아야 합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/192917162-cc1db97b-5e71-437e-863c-d215abe60689.png' width='40%'/>
  <img src='https://user-images.githubusercontent.com/31071467/192917165-3f5fb0f6-b547-4684-92e9-37aa58be25a4.png' width='30%'/>
  <br>
  <i>6개의 격자로 구성된 큐브</i>
</p>
<br>

사진에서 볼 수 있듯이 6개의 메시로 구성된 큐브를 만들 수 있습니다. 이것만 봐도 꽤 모양이 괜찮아 보이는데 실용적이진 않습니다. 따로 생성된 메시들을 [Mesh](https://docs.unity3d.com/ScriptReference/Mesh.html).CombineMeshes 메서드를 통해 합칠수도 있지만 애초에 처음부터 큐브 전체를 하나의 메시로 만들 수도 있습니다. 우리는 후자를 택할겁니다. (그게 강의 목표니까요!)

<p align='right'>
  <a href='https://catlikecoding.com/unity/tutorials/rounded-cube/rc-01-Compositing-a-Cube.unitypackage'>unitypackage</a>
</p>

<br>

## 2 큐브 정점 생성하기

큐브를 직접 만들기 위해 새 컴포넌트를 만들어봅시다. 어떻게든 이전 강의에서 썼던 코드를 재사용해서 만들어볼건데 3차원이라서 *zSize*만 우선 추가해줍니다. 이전 강의 마지막에 지웠던 코루틴이랑 기즈모 코드를 살려서 어떻게 생성되는지 과정을 볼 수 있게 하겠습니다.

```c#
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class Cube : MonoBehaviour {
    public int xSize, ySize, zSize;
  
    private Mesh mesh;
    private Vector3[] vertices;
  
    private void Awake() {
        StartCoroutine(Generate());
    }
  
    private IEnumerator Generate() {
        GetComponent<MeshFilter>().mesh = mesh = new Mesh();
        mesh.name = "Procedural Cube";
        WaitForSeconds wait = new WaitForSeconds(0.05f);
    
        yield return wait;
    }
  
    private void OnDrawGizmos() {
        if (vertices == null) {
            return;
        }
        Gizmos.color = Color.black;
        for (int i = 0; i < vertices.Length; i++) {
            Gizmos.DrawSphere(vertices[i], 0.1f);
        }
    }
}
```

이제 새로운 게임 오브젝트를 만들고 방금 만든 컴포넌트를 추가하세요. 기존에 있던 Grid 컴포넌트를 대체해도 됩니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/193169584-f90e9e59-019d-4713-9d5c-40da8e14490e.png' width='45%'/>
  <br>
  <i>세 번째 필드가 추가된 모습</i>
</p>
<br>

정점을 추가하기 전에 몇개를 추가해야 하는지를 먼저 파악해야 합니다. 이전 강의처럼 면 하나만 만드는 경우는 이미 몇개의 정점이 필요한지 알고 있습니다.

$$
(xSize + 1)(ySize + 1)
$$

큐브는 면이 6개니 그냥 다 더해주면 됩니다.

$$
2\lbrace(xSize + 1)(ySize + 1) + (xSize + 1)(zSize + 1) + (ySize + 1)(zSize + 1)\rbrace
$$

하지만 각 면의 가장자리에 있는 정점들은 다른 면과 겹치면서 두 번 중복되어 계산됩니다. 더군다나 각 면의 꼭짓점 4개는 세 개의 면과 겹치기 때문에 세 번 중복되어 계산됩니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/193171479-e2696067-2626-4691-9862-917eec31c784.png' width='45%'/>
  <br>
  <i>각 정점별 겹치는 횟수</i>
</p>
<br>

사실 이건 그렇게 문제가 되는 부분은 아닙니다. 정점이 겹치는거야 법선들로 뾰족한 모서리를 만들때 자주 볼 정도로 흔하기 때문에 그냥 무시하고 6개의 면을 각각 따로 계산하되 하나의 배열 안에 합쳐도 됩니다.

하지만 그건 강의 목적에 어긋나죠. 이미 격자를 만드는 방법을 알고 있기 때문에 학습 효과가 없습니다. 이전 것을 복사하지 않고 좀더 흥미로운 방법으로 큐브를 만들어봅시다.

자 그래서 얼마나 많은 정점이 필요할까요? 종류별로 나눠봅시다. 가장 쉬운 것부터 보자면 큐브는 육면체이므로 8개의 꼭짓점이 있습니다. 그리고 각 방향별로 4개씩 총 12개의 모서리가 있습니다. 꼭짓점을 포함하지 않기 때문에 각 모서리는 xSize, ySize, zSize에 1을 뺀 만큼의 정점을 가지고 있습니다. 혹은 X, Y, Z 모서리가 4개씩 있다고 생각하면 됩니다.

$$
4(xSize + ySize + zSize - 3)
$$

이제 남은 부분은 면 내부에 있는 정점들입니다. 이는 아까 계산한 중복된 점이 있는 큐브 식에서 각 변의 길이가 2씩 줄어든 것과 같습니다.

$$
2\lbrace(xSize - 1)(ySize - 1) + (xSize - 1)(zSize - 1) + (ySize - 1)(zSize - 1)\rbrace
$$

이걸 다 더하면 큐브를 만드는데에 필요한 정점 개수를 알 수 있습니다.

```c#
private IEnumerator Generate() {
    GetComponent<MeshFilter>().mesh = mesh = new Mesh();
    mesh.name = "Procedural Cube";
    WaitForSeconds wait = new WaitForSeconds(0.05f);
  
    int cornerVertices = 8;
    int edgeVertices = (xSize + ySize + zSize - 3) * 4;
    int faceVertices = (
        (xSize - 1) * (ySize - 1) +
        (xSize - 1) * (zSize - 1) +
        (ySize - 1) * (zSize - 1)) * 2;
    vertices = new Vector3[cornerVertices + edgeVertices + faceVertices];
  
    yield return wait;
}
```
