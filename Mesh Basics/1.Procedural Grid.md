> 번역본에 사용된 이미지, 코드와 같은 모든 리소스와 내용 그 자체의 출처를 아래 명시합니다.<br>
> https://catlikecoding.com/unity/tutorials/procedural-grid/

> original author: Jasper Flick (Catlike Coding)<br>
> translator: Minjong Kim (IDstorage)<br>
> lastest update: 2022.09.22

<br>

# 절차적 격자
#### 형태 만들기

> 점으로 된 격자 만들기<br>
> 격자 배치를 분석하기 위해 코루틴 써보기<br>
> 삼각형들로 면 만들어보기<br>
> 텍스쳐 좌표와 탄젠트 추가해보기<br>

<br>

이번 강의에서는 정점과 삼각형들로 이루어진 간단한 격자를 만들어 볼겁니다.

들어가기 앞서 해당 강의는 기본적인 Unity 스크립팅에 대한 지식이 필요합니다. 만약 부족하다면 [게임 오브젝트와 스크립트]() 강의를 보고 오세요. 코루틴(coroutine)에 대한 내용은 [프랙탈 만들기]() 강의에서 다룹니다.

> 이 강의는 Unity 5.0.1 버전이나 그 이상을 다루고 있습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191639070-38b8b8ec-173b-42e6-905b-47317d1ba89c.jpg' width='50%'/>
  <br>
  <i>복잡한 외관과 달리 그 속에는 생각보다 단순한 기하학적 구조가 숨어있습니다.</i>
</p>
<br>

## 1 아무거나 렌더링 해보기

Unity에서는 메시(mesh)를 사용해서 원하는 것을 시각화할 수 있습니다. 외부 툴에서 뽑아온 3D 모델도, 절차적 생성을 거친 메시도, 이미지, UI, 파티클 시스템도 모두 메시를 사용합니다. 심지어 화면 효과(screen effect)마저도 메시를 사용해 렌더링합니다.

그래서 그 메시라는건 도대체 뭘까요? 메시는 개념상 복잡한 물체를 그리기 위해 그래픽 하드웨어가 사용하는 구조를 의미합니다. 여기엔 공통적으로 3D 공간의 점을 나타내는 정점 집합과 이들을 연결하여 구성하는 가장 간단한 2차원 도형인 삼각형들의 집합을 내포하고 있습니다. 이 삼각형들은 메시가 나타내려는 물체의 표면을 구성합니다.

익히 알고 있듯 삼각형은 날이 서있고 (2차원 도형이니 당연히) 납작합니다. 그래서 육면체처럼 평평하거나 직선뿐인 면을 시각화하기에는 최적의 도형입니다. 하지만 곡면의 경우 완벽하게 표현할 수는 없고 작은 삼각형을 많이 배치해 곡면과 유사하게 표현할 수밖에 없습니다. 물론 이 삼각형의 크기를 픽셀에 수렴할 정도로 작게 만들면 유사곡면이라는 것을 눈치채지 못하겠지만 보통 성능 이슈로 실현 불가능합니다. 그래서 어느정도는 표면이 각져 보이게 두는 겁니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191639021-caf18bd2-2a7c-4559-b1b0-bdba7fb09206.png' width='60%'/>
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191639030-772a0b5a-be52-49cc-bacb-241ec02ac33e.png' width='60%'/>
  <br>
  <i>Shaded와 Wireframe으로 본 Unity 기본 제공 캡슐, 정육면체, 구</i>
</p>
<br>

><details>
> <summary>와이어프레임으로 어떻게 보나요?</summary>
> 	<br>Scene뷰 툴바에서 디스플레이 모드를 선택할 수 있습니다. 가장 위에 있는 세 가지 옵션이 각각 Shaded, Wireframe, Shaded Wireframe 입니다.
> </details>
<br>

3D 모델을 띄우는 게임 오브젝트를 만드려면 두 가지 컴포넌트가 필요합니다. 대상이 되는 메시를 참조하는 [MeshFilter](https://docs.unity3d.com/ScriptReference/MeshFilter.html) 컴포넌트와 그 메시가 어떻게 렌더링 될지 머터리얼, 그림자 등을 설정하는 [MeshRenderer](https://docs.unity3d.com/ScriptReference/MeshRenderer.html) 컴포넌트 입니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191677003-01a7a927-b298-49cc-a9c4-365e5b168e2f.png' width='50%'/>
  <br>
  <i>Unity 기본 큐브 게임 오브젝트</i>
</p>
<br>

><details>
> <summary>왜 머터리얼 필드는 배열로 되어 있나요?</summary>
> 	<br><a href="https://docs.unity3d.com/ScriptReference/MeshRenderer.html">MeshRenderer</a>는 여러 머터리얼들을 참조할 수 있습니다. 서브 메시(submesh)라고 하는 여러 분리된 삼각형 집합을 가지는 메시를 렌더링할 때 사용됩니다. 대개 3D 모델을 불러올 때 사용되니 이 강의에서는 다루지 않습니다.
> </details>
<br>

머터리얼을 수정하는 것 만으로도 메시의 외형을 완전히 바꿀 수 있습니다. Unity의 기본 머터리얼은 아무 것도 없는 흰색인데 이를 우리가 만든 새 머터리얼로 교체할 수 있습니다. Project뷰에서 *Assets / Create / Material* 을 눌러 새 머터리얼을 만들고 게임 오브젝트로 드래그하면 됩니다. 새로 만들어진 머터리얼은 적용할 표면을 원하는대로 조절할 수 있는 옵션들을 제공하는 Unity의 표준 셰이더(Standard shader)를 기본으로 사용합니다.

가장 빠르게 메시에 디테일을 주려면 알베도 맵(albedo map)을 적용하면 됩니다. 알베도 맵은 머터리얼의 색상을 정하는 텍스쳐를 나타냅니다. 물론 메시의 삼각형들에 이 텍스쳐를 어떻게 투영 시키는지 알 필요가 있습니다. 간단히 2D 텍스쳐의 좌표를 정점에 대응 시켜 텍스쳐를 투영시킬 수 있습니다. 텍스쳐 공간의 좌표는 U와 V를 사용해 나타내며 이를 UV 공간이라고 합니다. 이때 U와 V는 각각 텍스쳐 공간의 X 좌표와 Y좌표를 0 ~ 1 사이 값으로 보간하여 표현합니다. 이 영역을 벗어난 좌표를 UV 공간에서 나타낼 때는 텍스쳐 설정에 따라 0 또는 1로 제한되거나(clamp), 모듈러 연산을 한 것 처럼 1 다음은 다시 0부터 시작하도록(tiling) 조절합니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191677072-fb1c58db-cd02-4099-b614-40ff404e9c64.png' width='25%'/>
  <img src='https://user-images.githubusercontent.com/31071467/191677102-1d9f83f7-94c2-4a8a-a60f-1ef69237068c.png' width='45%'/>
  <br>
  <img src='https://user-images.githubusercontent.com/31071467/191677111-09ee19bc-4146-4965-9617-87c07f3872df.png' width='60%'/>
  <br>
  <i>UV 공간을 테스트 하기 위해 텍스쳐를 적용한 Unity의 기본 메시들</i>
</p>
<br>

<p align='right'>
  <a href='https://catlikecoding.com/unity/tutorials/procedural-grid/pg-01-rendering-things.unitypackage'>unitypackage</a>
</p>

<br>

## 2 정점으로 된 격자 만들기

기본 제공이나 불러오는 것 말고 코드로 직접 나만의 메시를 만들어 봅시다. 쿼드(quad)라고 하는 정사각형 타일을 단위로 하는 간단한 직사각형 모양 격자를 만들겁니다.  새 C# 스크립트를 만들고 가로, 세로 길이를 필드로 지닌 Grid 컴포넌트로 정의합니다.

```c#
using UnityEngine;
using System.Collection;

public class Grid : MonoBehaviour {
	public int xSize, ySize;
}
```

><details>
> <summary>System.Collections 도 사용하나요?</summary>
> 	<br>메시를 만들 때는 딱히 필요가 없습니다. 이따가 코루틴을 사용하기 위해 추가해뒀습니다.
> </details>
<br>

Grid 컴포넌트가 게임 오브젝트에 추가될 때 [MeshFilter](https://docs.unity3d.com/ScriptReference/MeshFilter.html) 컴포넌트와 [MeshRenderer](https://docs.unity3d.com/ScriptReference/MeshRenderer.html) 컴포넌트도 함께 있어야 메시를 제대로 보여줄 수 있습니다. Unity로 하여금 두 컴포넌트를 자동으로 추가할 수 있게 어트리뷰트(attribute)를 추가합니다.

```c#
[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class Grid : MonoBehaviour {
	public int xSize, ySize;
}
```

이제 새 게임 오브젝트를 만들고 Grid 컴포넌트를 붙여보면 원했던 두 컴포넌트들도 같이 추가되는 것을 볼 수 있습니다. [MeshRenderer](https://docs.unity3d.com/ScriptReference/MeshRenderer.html) 컴포넌트의 머터리얼에 아까 만든 머터리얼을 등록하고 [MeshFilter](https://docs.unity3d.com/ScriptReference/MeshFilter.html) 컴포넌트는 None인 상태로 둡니다. 격자 크기는 $10 \times 5$로 하겠습니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191677186-8a2850fc-390f-49cf-882f-fe31b05c9ce0.png' width='50%'/>
  <br>
  <i>마법이 일어날 Grid 오브젝트</i>
</p>
<br>

게임이 실행되고 컴포넌트가 할당되자마자 실제 메시를 생성해줍니다.

```c#
private void Awake() {
	Generate();
}
```

메시에 필요한 요소로 정점 집합과 삼각형 집합이 있다고 했었죠? 잠시 삼각형은 잊고 정점에만 집중해봅시다. 정점들의 집합을 저장하려면 3D 벡터(Vector3) 배열이 필요합니다. 배열의 크기는 격자 크기를 따라갈겁니다. 모든 쿼드는 각각 4개의 정점들을 가지고 있습니다. 하지만 쿼드는 모두 붙어있으니 인접한 쿼드끼리는 같은 정점을 공유합니다. 그래서 각 행과 열의 정점의 수는 격자 크기보다 하나씩 더 많습니다.

$(xSize+1) \times (ySize+1)$

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191677228-b37a47f8-c5c5-4cd3-8ba2-ff09718dd130.png' width='40%'/>
  <br>
  <i>4 x 2 격자의 정점과 쿼드 번호</i>
</p>
<br>

```c#
private Vector3[] vertices;

private void Generate() {
	vertices = new Vector3[(xSize + 1) * (ySize + 1)];
}
```

이제 정점을 제대로 배치했는지 화면에 표시해서 확인해봅시다. [OnDrawGizmos](https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmos.html) 메서드를 추가하고 각 정점의 위치에 검은색 작은 구를 Scene뷰에 표시합니다.

```c#
private void OnDrawGizmos() {
	Gizmos.color = Color.black;
	for (int i = 0; i < vertices.Length; i++) {
		Gizmos.DrawSphere(vertices[i], 0.1f);
	}
}
```

><details>
> <summary>기즈모(Gizmos)가 뭔가요?</summary>
> 	<br>기즈모는 에디터에서 사용 가능한 시각적인 표식입니다. 기본적으로 Game뷰에서는 보이지 않고 Scene뷰에서만 보이지만 툴바에서 가시성을 수정할 수 있습니다. <a href='https://docs.unity3d.com/ScriptReference/Gizmos.html'>Gizmos</a> 유틸리티 클래스로 아이콘이나 선, 그 외의 것들을 그릴 수 있습니다.
> 	<br><br>
> 	기즈모는 <a href='https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmos.html'>OnDrawGizmos</a> 라는 Unity 이벤트 메서드에서만 그릴 수 있습니다. OnDrawGizmosSelected 메서드로 대체할 수도 있는데 이는 게임 오브젝트가 선택됐을 때만 호출되는 차이가 있습니다.
> </details>
<br>

코드를 저장하고 컴파일해보면 실행 중이 아닐 땐 아무 짓도 하지 않아도 에러를 내뿜는 에디터를 볼 수 있을겁니다.  이는 [OnDrawGizmos](https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmos.html) 메서드가 정점을 생성하는 Awake 메서드와는 다르게 에디터 상태일 때도 호출이 되기 때문인데, 할당되지 않은 정점 배열에 접근하여 오류가 발생하는 것입니다. 이 사태를 막으려면 [OnDrawGizmos](https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmos.html) 메서드에 정점 배열이 초기화되었는지 확인하는 코드를 추가해야 합니다.

```c#
private void OnDrawGizmos() {
	if (vertices == null) {
		return;
	}
	...
}
```

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191677274-b5d168dd-146e-424d-a26f-88c24b1910d8.png' width='40%'/>
  <br>
  <i>덩그러니 그려진 기즈모</i>
</p>
<br>

실행해보면 원점에 검은 구 하나만 덩그러니 있는 모습을 볼 수 있습니다. 정점 배열의 크기만 지정했지 각 정점의 값은 지정하지 않았기 때문에 모두 (0, 0, 0)을 가리켜 겹쳐보이는 것입니다. 이중 반복문으로 배열을 순회하며 위치를 배정해줍시다.

```c#
private void Generate() {
	vertices = new Vector3[(xSize + 1) * (ySize + 1)];
	for (int i = 0, y = 0; y <= ySize; y++) {
		for (int x = 0; x <= xSize; x++, i++) {
			vertices[i] = new Vector3(x, y);
		}
	}
}
```

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191677307-f9c5286a-64ad-41db-a5fc-4ceabc895132.png' width='50%'/>
  <br>
  <i>정점으로 이루어진 격자</i>
</p>
<br>

><details>
> <summary>왜 기즈모는 오브젝트를 따라 움직이지 않나요?</summary>
> 	<br>기즈모는 월드 공간에 직접 그리는 것이기 때문에 오브젝트의 로컬 공간의 영향을 받지 않습니다. 만약 오브젝트의 로컬 위치에 영향을 받도록 하고 싶다면 기즈모 생성 위치를 vertices[i]가 아닌 transform.TransformPoint(vertices[i]) 로 변경해주세요.
> </details>
<br>

이제 정점들이 잘 보입니다. 하지만 아직 배치되는 순서를 볼 수는 없습니다. 생성되는 정점의 색을 순서에 따라 달리하여 구분할 수도 있지만 코루틴을 사용해서 정점을 배치하는 작업을 느리게 만들 수도 있습니다. 드디어 아까 추가한 ```using System.Collection```이 빛을 발할 때가 온 것 같군요.

```c#
private void Awake() {
	StartCoroutine(Generate());
}

private IEnumerator Generate() {
	WaitForSeconds wait = new WaitForSeconds(0.05f);
	vertices = new Vector3[(xSize + 1) * (ySize + 1)];
	for (int i = 0, y = 0; y <= ySize; y++) {
		for (int x = 0; x <= xSize; x++, i++) {
			vertices[i] = new Vector3(x, y);
			yield return wait;
		}
	}
}
```

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/191677619-12cccf0b-2d3c-4925-800a-56a842e905d9.gif' width='50%'/>
  <br>
  <i>불멍하듯 정점이 추가되는걸 멍하니 바라봅시다.</i>
</p>
<br>

<p align='right'>
  <a href='https://catlikecoding.com/unity/tutorials/procedural-grid/pg-02-creating-a-grid-of-vertices.unitypackage'>unitypackage</a>
</p>

<br>

## 3 메시 만들기

이제 정점들이 제 위치에 배치된걸 확인하셨으니 진짜 메시를 만들어봅시다. 생성한 메시는 그냥 참조하는 것이 아닌 MeshFilter에도 할당해줘야 하며 그 후 배치한 정점들을 메시에 추가해야 합니다.

```c#
private Mesh mesh;

private IEnumerator Generate() {
	WaitForSeconds wait = new WaitForSeconds(0.05f);
	
	GetComponent<MeshFilter>().mesh = mesh = new Mesh();
	mesh.name = "Procedural Grid";
	
	vertices = new Vector3[(xSize + 1) * (ySize + 1)];
	...
	mesh.vertices = vertices;
}
```

> <details>
> <summary>메시를 필드로 참조하는 이유가 있을까요?</summary>
> 	<br>Generate 메서드에서 쓰기 위해 참조가 필요하지만 MeshFilter 컴포넌트가 어찌됐건 이를 참조하고 있으니 필드까지는 필요없습니다. 그럼에도 필드를 만든건 다음 강의에서 메시에 애니메이션을 적용해볼 예정이라 미리 만들었습니다. 그 강의도 꼭 들어보세요.
> </details>
<br>

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/192143592-a2334a70-de49-41e1-81de-5a22dabb64e8.png' width='50%'/>
  <br>
  <i>실행하면 메시가 생성됩니다.</i>
</p>
<br>

메시를 생성하긴 했지만 아무것도 보이지 않습니다. 메시가 가진 최소한의 구성 요소에 대해 설명했었죠? 정점 집합은 추가했지만 아직 삼각형 집합을 추가하지 않았습니다. 이 삼각형 집합은 정점 인덱스(index)의 배열로 이루어져 있습니다. 삼각(三角)형이 세 점을 가지고 있듯이 배열에서 연속된 세 정점 인덱스가 하나의 삼각형을 나타냅니다. 일단 하나만 만들어봅시다.

```c#
private IEnumerator Generate() {
	...
	
	int[] triangles = new int[3];
	triangles[0] = 0;
	triangles[1] = 1;
	triangles[2] = 2;
	mesh.triangles = triangles;
}
```

이제 삼각형 하나를 만들었지만 세 점이 모두 일직선상에 있습니다. 이 삼각형은 아무래도 찌그러져서 보이지 않겠네요. 첫번째, 두번째 정점은 괜찮습니다만 마지막 정점은 (정점 집합의) 다음 줄 첫번째 정점이 되어야 삼각형 모양을 만들 수 있습니다.

```c#
triangles[0] = 0;
triangles[1] = 1;
triangles[2] = xSize + 1;
```

이번엔 진짜 보이는 삼각형 하나를 만들었지만 그마저도 한 방향에서만 보입니다. 이 경우엔 Z축의 반대 방향에서만 삼각형이 보일겁니다. 그래서 실행한 후 카메라로 볼 수 있게 돌려야 합니다.

삼각형의 어느 면이 보이냐는 정점 인덱스의 순서에 따라 달라집니다. 기본적으로, 정점 인덱스가 시계 방향으로 나열되어 있는 쪽이 보이는 면(앞면)입니다. 반시계 방향인 경우 안 보이는 면으로, 렌더링 시간을 줄이기 위해 버립니다.

<br>
<p align='center'>
  <img src='https://user-images.githubusercontent.com/31071467/192144140-4be13e3a-b263-4939-aab2-dbb9923bdec6.png' width='50%'/>
  <br>
  <i>각각 보이는 면(앞면)과 안 보이는 면(뒷면)</i>
</p>
<br>
